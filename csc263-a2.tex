\documentclass{article}
\usepackage{amsmath,amssymb,graphicx,tikz}
\usepackage{hyperref}
\usepackage{tikz}
\usepackage{amsfonts}
\usepackage{amsmath}
\usepackage{listings}

\title{CSC263 Winter 2016, Assignment 2}
\author{Connor Peet \#1001088208}
\renewcommand{\today}{~}
\hypersetup{pdfpagemode=Fullscreen,
  colorlinks=true,
  linkfileprefix={}}
\begin{document}
\maketitle

\lstset{
    numbers=left
}

\begin{enumerate}
\item [1.] See figures 1 and 2 on the following page.
    \begin{figure}[p]
    \centering
    \begin{tikzpicture}[
        level/.style={sibling distance=45mm/#1, level distance = 15mm},
        every node/.style={align=center},
        label distance=0mm,
        every label/.style={text width=20mm, below},
    ]
    \tikzstyle{every label}=[font=\footnotesize]
    \node[circle,draw,label=\texttt{BF = 1}]{5}
        child{ node[circle,draw, label=\texttt{BF = -1}]{0}
            child{ node[circle,draw,label=\texttt{BF = -1}]{-2}
                child{ node[circle,draw,label=below:\texttt{BF = 0}]{-5} }
                child[missing]{}
            }
            child{ node[circle,draw,label=below:\texttt{BF = 0}]{2} }
        }
        child{ node[circle,draw,label=\texttt{BF = -1}]{19}
            child{ node[circle,draw,label=\texttt{BF = -1}]{13}
                child{ node[circle,draw,label=\texttt{BF = 1}]{6}
                    child[missing]{}
                    child{ node[circle,draw,label=below:\texttt{BF = 0}]{7} }
                }
                child{ node[circle,draw,label=below:\texttt{BF = 0}]{14} }
            }
            child{ node[circle,draw,label=\texttt{BF = 1}]{25}
                child[missing]{}
                child{ node[circle,draw,label=below:\texttt{BF = 0}]{28} }
            }
        };
    \end{tikzpicture}
    \caption{The resulting AVL tree $T$.}
    \end{figure}

    \begin{figure}[p]
    \centering
    \begin{tikzpicture}[
        level/.style={sibling distance=45mm/#1, level distance = 15mm},
        every node/.style={align=center},
        label distance=0mm,
        every label/.style={text width=20mm, below},
    ]
    \tikzstyle{every label}=[font=\footnotesize]
    \node[circle,draw,label=\texttt{BF = 0}]{13}
        child{ node[circle,draw, label=\texttt{BF = 0}]{5}
            child{ node[circle,draw,label=\texttt{BF = 0}]{-2}
                child{ node[circle,draw,label=below:\texttt{BF = 0}]{-5} }
                child{ node[circle,draw,label=below:\texttt{BF = 0}]{0} }
            }
            child{ node[circle,draw,label=\texttt{BF = 1}]{6}
                child[missing]{}
                child{ node[circle,draw,label=below:\texttt{BF = 0}]{7} }
            }
        }
        child{ node[circle,draw,label=\texttt{BF = 1}]{19}
            child{ node[circle,draw,label=\texttt{BF = 0}]{14} }
            child{ node[circle,draw,label=\texttt{BF = 1}]{25}
                child[missing]{}
                child{ node[circle,draw,label=below:\texttt{BF = 0}]{28} }
            }
        };
    \end{tikzpicture}
    \caption{$T$ after deleting $2$ and executing the necessary rotations.}
    \end{figure}

\item [2.] First we define a \texttt{pull\_root} function that takes removes and returns either the smallest element of $B_2$ or the largest element of $B_1$.
\begin{lstlisting}
def pull_root(B1, B2):
    node_b1 = B1.root
    node_b2 = B2.root

    while True:
        if node_b1.right == nil:
            if node_b1.parent != nil:
                node_b1.parent.right = nil
            return node_b1

        elif node_b2.left == nil:
            if node_b2.parent != nil:
                node_b2.parent.left = nil
            return node_b2

        node_b1 = node_b1.right
        node_b2 = node_b2.left
\end{lstlisting}

    The function to merge the trees is a trivial extension of \texttt{pull\_root}:
\begin{lstlisting}
def merge(B1, B2):
    root = pull_root(B1, B2)
    root.left = B1
    root.right = B2
    B1.parent = root
    B2.parent = root
\end{lstlisting}

    In this function, we're running down the right-most subtrees of $B_1$ and left-most subtrees of $B_2$ until we get to the leaf of either. This relies on the invariants of BSTs. When the node is found, it's removed from its parent and returned. The while loop will run at most $min\{h_1, h_2\}$ times--it loops down $B_1$ and $B_2$ and aborts as soon as it reaches a leaf of either--and each function inside the loop takes a constant time, so the function is in $O(min\{h_1, h_2\})$. \\

    The leaf that's removed and returned is either the largest item in $B_1$ or the smallest item in $B_2$. In both cases this item can be assigned to the root of the tree while preserving the BST property. \\

    The maximum height change occurs when the removed leaf was not the single deepest node out of both trees. When this occurs, the height of the new tree $T$ is $max\{h_1, h_2\} + 1$ as the result of inserting a new root above the subtrees. If this is not the case, then height of $T$ will equal $max\{h_1, h_2\}$.

\item [3.] To create this `rolling median' I'll use not one, but two augmented heaps. The first heap, $H_1$ is a max-heap and the second $H_2$ is a min-heap. The augmentation is simple: the root of each heap will record its total size. The following algorithms can be used to insert and find the median of heaps $H_1$ and $H_2$. For conciseness, algorithms already defined in the textbook (heap insert and extraction) are not shown, nor the trivial modification to the insert function to maintain the heap sizes.
\begin{lstlisting}
def median(H1, H2):
    if H1.size > H2.size:
        return H1.root
    else:
        return (H1.root + H2.root) / 2

def insert(H1, H2, x):
    if H1.size == 0 or x <= H1.root:
        H1.insert(x)
    else:
        H2.insert(x)

    while H2.size > H1.size:
        H1.insert(H2.extract_root())
    while H1.size > H2.size + 1:
        H2.insert(H1.extract_root())
\end{lstlisting}
    Notes on correctness of \texttt{median}:
    \begin{enumerate}
        \item It's invariant that $H_1$ always has either $H_2.size$ or $H_2.size + 1$ items. This is maintained in lines 13 through 16 of \texttt{insert}; items are rebalanced to ensure this is the case.
        \item It's also invariant that all items in $H_1$ are less than or equal to $H_2$.
            \begin{itemize}
            \item The first item is inserted in $H_1$, so the invariant holds.
            \item The \textit{i}th item is inserted in $H_1$ iff it's less than or equal to the root, which is greater than all its other elements due to the max-heap property. Otherwise, it's inserted into $H_2$, as it's greater than the largest element in $H_1$.
            \item When a rebalance happens (lines 13 to 16), either the largest element from $H_1$ is moved to $H_2$, or the smallest element is moved from $H_2$ to $H_1$. In both cases, the invariant holds.
            \end{itemize}
        \item Also, by (a), $H_1.size$ is larger than $H_2.size$ only if there is an odd number of items in the tree.
        \item Then two heaps' roots are two of the numbers closest to the median.
            \begin{itemize}
            \item If $n$ is odd, we return the $H_1.root$, which is the median.
            \item If $n$ is even, we return the average of the roots, which is correct.
            \end{itemize}
    \end{enumerate}
\end{enumerate}
\end{document}
